#ifndef __HIDDENMARKOVMODEL_HPP
#define __HIDDENMARKOVMODEL_HPP

#include <iostream>
#include <sstream>
#include <exception>
#include <stdexcept>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>	
#include <math.h>	// log, exp
#include <utility>	// std::pair
#include <memory> // std::shared_ptr
#include <iomanip> // std::setprecision
#include "constants.hpp"
#include "state.hpp"
#include "graph.hpp"
#include "utils.hpp"
#define CYAN "\033[36m"
#define RESET "\033[0m"

template<typename Elem>
using Matrix = std::vector<std::vector<Elem>>;

std::string print_matrix(const Matrix<double>& matrix, const std::map<std::string, std::size_t>& indices, bool log_prob = false){
	std::size_t longest_string = 0;
	for(std::size_t i = 0; i < matrix.size(); ++i){
		for(std::size_t j = 0; j < matrix[i].size(); ++j){
			std::string double_string = (log_prob) ? std::to_string(matrix[i][j]) : std::to_string(exp(matrix[i][j]));
			if(double_string.length() > longest_string) longest_string = double_string.length();
		}
	}
	std::vector<std::string> sorted_names(indices.size());
	std::ostringstream out;
	for(auto& pair : indices) {
		sorted_names[pair.second] = pair.first;
	}
	out << std::string(longest_string + 1, ' ');
	for(std::string& name : sorted_names) {
		out << std::string(longest_string - name.length(), ' ');
		out << CYAN << name << RESET;
		out << ' ';
	}
	out << std::endl;
	for(std::size_t i = 0; i < matrix.size(); ++i){
		out << std::string(longest_string - sorted_names[i].length(), ' ');
		out << CYAN << sorted_names[i] << RESET;
		out << ' ';
		for(std::size_t j = 0; j < matrix[i].size(); ++j){
			std::string double_string = (log_prob) ? std::to_string(matrix[i][j]) : std::to_string(exp(matrix[i][j]));
			out << std::string(longest_string - double_string.length(), ' ');
			out << double_string;
			out << ' ';
		}
		out << std::endl;
	}
	return out.str();	
}

std::ostream& operator<<(std::ostream& out, const std::vector<double>& vec){
	for(double d : vec){
		out << exp(d) << " ";
	}
	out << std::endl;
	return out;
}

std::ostream& operator<<(std::ostream& out, const std::vector<Distribution*>& vec){
	for(const Distribution* dist : vec){
		if(dist == nullptr) out << "Silent" << std::endl;
		else out << *dist << std::endl;
	}
	return out;
}

/* <-------- Exceptions --------> */

class HMMException : public std::logic_error {
protected:
	HMMException(const std::string& message) :
		std::logic_error(message) {}
};

class StateNotFoundException : public HMMException {
public:
	template<typename T>
	StateNotFoundException(const T& t, const std::string& msg) : 
		HMMException(error_message::format("StateNotFoundException: " + msg, t)) {}

	StateNotFoundException(const std::string& msg) : 
		HMMException("StateNotFoundException: " + msg) {}
};

class StateExistsException : public HMMException {
public:
	template<typename T>
	StateExistsException(const T& t, const std::string& msg) : 
		HMMException(error_message::format("StateExistsException: " + msg, t)) {}
};

class TransitionNotFoundException : public HMMException {
public:
	template<typename T>
	TransitionNotFoundException(const T& t, const std::string& msg) : 
		HMMException(error_message::format("TransitionNotFoundException: " + msg, t)) {}

	TransitionNotFoundException(const std::string& msg) : 
		HMMException("TransitionNotFoundException: " + msg) {}
};

class TransitionExistsException : public HMMException {
public:
	template<typename T>
	TransitionExistsException(const T& t, const std::string& msg) : 
		HMMException(error_message::format("TransitionExistsException: " + msg, t)) {}
};

class TransitionLogicException : public HMMException {
public:
	template<typename T>
	TransitionLogicException(const T& t, const std::string& msg) : 
		HMMException(error_message::format("TransitionLogicException: " + msg, t)) {}
};

/* <----------------------------> */

class HiddenMarkovModel {
private:
	/* Name of this hmm. */
	std::string _name;

	/* Begin and end states. */
	State* _begin;
	State* _end;

	/* Holds the states and the transitions when building the hmm. */
	Graph<State> _graph;

	/* Generated by brew. */
	std::map<std::string, std::size_t> _states_indices;
	std::vector<std::string> _states_names;
	Matrix<double> _A;
	std::vector<Distribution*> _B;
	bool _is_finite;
	std::size_t _silent_states_index;
	std::size_t _M; //TODO
	std::size_t _N;

	void _clear_raw_data() {
		for(Distribution* dist : _B){
			if(dist != nullptr) delete dist;
		}
		_states_indices.clear();
		_states_names.clear();
		_A.clear();
		_is_finite = false;
		_silent_states_index = std::size_t();
		_M = std::size_t(); 
		_N = std::size_t();
	}

public:
	/* Default constructor. Inits an empty hmm with default values. */
	HiddenMarkovModel() : 
		HiddenMarkovModel(std::to_string((ptrdiff_t)this)) {}

	HiddenMarkovModel(const std::string& name) : 
		HiddenMarkovModel(name, State(hmm_config::kDefaultStartStateLabel + name), 
			State(hmm_config::kDefaultEndStateLabel + name)) {}

	HiddenMarkovModel(const State& begin, const State& end) :
		HiddenMarkovModel(std::to_string((ptrdiff_t)this), begin, end) {}

	/* Complete constructor. */
	HiddenMarkovModel(const std::string& name, const State& begin, const State& end) : 
		_name(name), _begin(nullptr), _end(nullptr), _graph() {
			_graph.add_vertex(begin);
			_begin = _graph.get_vertex(begin);
			_graph.add_vertex(end);
			_end = _graph.get_vertex(end);
	}

	std::string name() const { return _name; }
	void set_name(const std::string& name) { _name = name; } 
	std::size_t num_states() const { return _graph.num_vertices(); }
	std::size_t num_transitions() const { return _graph.num_edges(); }	

	bool has_state(const State& state) const {
		return _graph.has_vertex(state);
	}

	bool has_transition(const State& from_state, const State& to_state) const {
		return _graph.has_edge(from_state, to_state);
	}

	State& begin() { 
		if(_begin != nullptr){
			return *_begin;
		}
		else{
			throw StateNotFoundException(error_message::kHMMHasNoBeginState);
		}
	}

	State& end() {
		if(_end != nullptr){
			return *_end;
		}
		else{
			throw StateNotFoundException(error_message::kHMMHasNoEndState);
		}
	}

	/* See behavior of Graph::add_vertex() */	
	void add_state(const State& state){
		try{
			_graph.add_vertex(state);	
		}
		catch(const VertexExistsException<State>& e){
			throw StateExistsException(e.trigger(), error_message::kHMMAddStateExists);
		}
	}

	/* See behavior of Graph::remove_vertex() */
	void remove_state(const State& state){
		if(state == *_begin) _begin = nullptr;
		else if(state == *_end) _end = nullptr;
		try{
			_graph.remove_vertex(state);	
		}
		catch(const VertexNotFoundException<State>& e){
			throw StateNotFoundException(e.trigger(), error_message::kHMMRemoveStateNotFound);
		}
	}

	std::string transition_string(const State& from, const State& to) const {
		return from.to_string() + " -> " + to.to_string();
	}

	/* See behavior of Graph::add_edge() */
	void add_transition(const State& from, const State& to, double probability){
		if(from == end()) throw TransitionLogicException(transition_string(from, to), error_message::kAddedTransitionFromEndState);
		if(to == begin()) throw TransitionLogicException(transition_string(from, to), error_message::kAddedTransitionToBeginState);
		if(probability < 0) throw TransitionLogicException(transition_string(from, to), error_message::kAddedTransitionNegativeProbability);
		try{
			_graph.add_edge(from, to, probability);	
		} 
		catch(const EdgeExistsException<Edge<State>>& e){
			throw TransitionExistsException(transition_string(*(e.trigger().from()), *(e.trigger().to())), error_message::kHMMAddTransitionExists);
		}
		catch(const IncidentVertexNotFoundException<State>& e){
			throw StateNotFoundException(e.trigger(), error_message::kAddTransitionStateNotFound);
		}
	}

	void begin_transition(const State& state, double probability) {
		add_transition(begin(), state, probability);
	}

	void end_transition(const State& state, double probability) {
		add_transition(state, end(), probability);
	}

	/* See behavior of Graph::remove_edge() */
	void remove_transition(const State& from, const State& to){
		try{
			_graph.remove_edge(from, to);	
		}
		catch(const EdgeNotFoundException<Edge<State>>& e){
			throw TransitionNotFoundException(transition_string(*(e.trigger().from()), *(e.trigger().to())), error_message::kHMMRemoveTransitionNotFound);
		}
		
	}

	/* Prepares the hmm before calling algorithms on it. */
	void brew() {
		/* Get rid of previous data. */
		_clear_raw_data();

		/* Get the states from graph. */
		std::vector<State*> states = _graph.get_vertices();
		std::size_t num_states = states.size(); 

		/* Remove begin and end states. */
		states.erase(std::remove(states.begin(), states.end(), [this](State* p_state){ return (*p_state) == begin() || (*p_state) == end(); }), states.end());
		std::vector<State*> silent_states;

		/* Keep track of the matrix index of each state. */
		std::map<std::string, std::size_t> states_indices;
		std::vector<std::string> states_names(num_states);

		/* Raw transition matrix. Init its size. 
		Begin and state transitions are stored in first row and first column, respectively.
		We therefore set its size to M - 1. */
		Matrix<double> A(num_states - 1);

		/* Transitions to end state exist and is not empty. */
		bool finite = false;

		/* Check if silent/end states are silent. */
		if(!begin().is_silent()) { throw std::logic_error("begin state has to be silent."); }
		if(!end().is_silent()) { throw std::logic_error("end state has to be silent."); }

		/* State index start at 1, first row/column is reserved for begin/end state. */
		states_indices[begin().name()] = 0;
		states_indices[end().name()] = 0;
		/* Default values set to negative infinity since we use log probabilites. */
		A[0] = std::vector<double>(num_states - 1, utils::kNegInf);
		std::size_t normal_states_index = 1;
		for(State* p_state : states){
			if(p_state->is_silent()) {
				silent_states.push_back(p_state);
			}
			else{
				A[normal_states_index] = std::vector<double>(num_states - 1, utils::kNegInf);
				/* Map state name to row index. */
				states_indices[p_state->name()] = normal_states_index;
				states_names[normal_states_index] = p_state->name();
				++normal_states_index;
			}
		}
		std::size_t num_silent_states = silent_states.size();
		/* This points to the beginning of the silent states array in A and B. */
		std::size_t silent_states_index = normal_states_index;
		/* We use a topological sort on the silent states sub graph in order to adapt 
		the HMM to silent states. */
		/* See p. 71 at http://www.upch.edu.pe/facien/fc/dbmbqf/zimic/ubioinfo/bks/Bioinformatics/Biological%20Sequence%20Analysis%20Hmm%20Bioinformatics%20(Durbin).pdf */
		/* Start by dereferencing silent states pointers to pass them to subgraph. */
		std::vector<State> silent_states_values(num_silent_states);
		std::transform(silent_states.begin(), silent_states.end(), silent_states_values.begin(), [](State* p){ return *p; });
		Graph<State> subgraph = _graph.sub_graph(silent_states_values);
		subgraph.topological_sort();
		/* Get toposorted silent states. */
		silent_states = subgraph.get_vertices();
		/* Init the toposorted silent states rows in the matrix. */
		for(State* p_silent_state : silent_states){
			A[silent_states_index] = std::vector<double>(num_states - 1, utils::kNegInf);
			states_indices[p_silent_state->name()] = silent_states_index;
			states_names[silent_states_index] = p_silent_state->name();
			++silent_states_index;
		}

		/* Fill transitions with log probabilities and check whether a normalization is needed. */
		auto fill_normalize = [&states_indices] (const std::vector<Edge<State>*>& edges, std::vector<double>& prob_vec_to_fill) {
			auto state_index = [&states_indices](const Edge<State>* edge){ return states_indices[edge->to()->name()]; };
			double prob_sum = 0;
			double prob;
			for(Edge<State>* edge : edges){
				prob = (edge->weight() == nullptr) ? 0 : *(edge->weight());
				prob_sum += prob;
				prob_vec_to_fill[state_index(edge)] = log(prob);
			}
			if(prob_sum != 1.0){
				utils::for_each_log_normalize(prob_vec_to_fill.begin(), prob_vec_to_fill.end(), log(prob_sum));
			}
			return prob_sum;
		};

		/* Add the begin state transitions. */
		State& begin_state = begin();
		if(_graph.get_in_edges(begin_state).size() > 0) { throw std::logic_error("begin state cannot have predecessors"); }
		std::vector<Edge<State>*> out_edges = _graph.get_out_edges(begin_state);
		/* Begin transitions are added in the first row of A s.t. A[0][i] == pi[i]. */
		double prob_sum = fill_normalize(out_edges, A[0]);
		if(prob_sum == 0.0) { throw std::logic_error("hmm has no begin transition"); }
		
		/* Check if end state has out edges. */
		State& end_state = end();
		if(_graph.get_out_edges(end_state).size() > 0) { throw std::logic_error("end state cannot have successors"); }

		/* Iterate through all the other states and add them to the matrix. */
		for(State* p_state : states){
			/* Fill normal transitions aka matrix A. */
			std::vector<Edge<State>*> out_edges = _graph.get_out_edges(*p_state);
			double prob_sum = fill_normalize(out_edges, A[states_indices[p_state->name()]]);
			if(prob_sum == 0.0) { throw std::logic_error("hmm has no transition from " + p_state->to_string()); }
		}

		/* Determine whether the hmm is finite by summing the end state in transitions probabilities. */
		double prob_sum_to_end = utils::kNegInf;
		for(std::size_t i = 0; i < A.size(); ++i) { prob_sum_to_end += exp(A[i][0]); }
		if(prob_sum_to_end > 0.0) { finite = true; }

		/* Fill emission matrix with the states PDFs. */
		std::vector<Distribution*> B(num_states);
		for(State* p_state : states){
			Distribution* distribution = nullptr;
			if(! state->is_silent()) {
				distribution = state->distribution().clone();
				distribution->log_normalize();
			}
			B[states_indices[state->name()]] = distribution;
		}

		/* Set fields for the hmm raw values. */
		_A = std::move(A);
		_B = std::move(B);
		_states_indices = std::move(states_indices);
		_states_names = std::move(states_names);
		_is_finite = finite;
		_silent_states_index = silent_states_index;
	}

	Matrix<double>& raw_transitions() { return _A; }
	std::vector<Distribution*>& raw_pdfs() { return _B; }
	std::map<std::string, std::size_t>& states_indices() { return _states_indices; }

	template<typename SymbolContainer>
	std::vector<double> forward(const SymbolContainer& symbols, std::size_t t_max = 0) {
		if(t_max == 0) t_max = symbols.size();
		auto init_forward = [&symbols, this]() -> std::vector<double> {
			std::vector<double> init_fwd(_A.size());
			/* Begin state has probability of 1 (log is 0), others 0 (log is negative infinity). */
			init_fwd[0] = 0.0;
			for(std::size_t i = 1; i < _A.size(); ++i) { 
				init_fwd[i] = utils::kNegInf;
			}
			return init_fwd;
		};
		auto iter_forward = [&symbols, this](const std::vector<double>& previous_fwd, std::size_t t) -> std::vector<double> {
			std::vector<double> current_fwd(_A.size());
			/* Do first normal states. */
			for(std::size_t j = 0; j < _silent_states_index; ++j){
				double prob_sum = utils::kNegInf;
				for(std::size_t i = 0; i < _A.size(); ++i){
					prob_sum = utils::sum_log_prob(prob_sum, previous_fwd[i] + _A[i][j]);	
				}
				current_fwd[j] = prob_sum + (*_B[j])[symbols[t]];
			}
			/* Do first iteration over silent states j with i == normal state. */
			for(std::size_t j = _silent_states_index; j < _A.size(); ++j){
				double prob_sum = utils::kNegInf;
				for(std::size_t i = 0; i < _silent_states_index; ++i){
					prob_sum = utils::sum_log_prob(prob_sum, current_fwd[i] + _A[i][j]);
				}
				current_fwd[j] = prob_sum;
			}
			/* Do second iteration over silent states j with i == silent state < j. */
			for(std::size_t j = _silent_states_index; j < _A.size(); ++j){
				double prob_sum = current_fwd[j];
				for(std::size_t i = _silent_states_index; i < j; ++i){
					prob_sum = utils::sum_log_prob(prob_sum, current_fwd[i] + _A[i][j]);
				}
				current_fwd[j] = prob_sum;
			}
			return current_fwd;
		};
		
		if(symbols.size() == 0) throw std::logic_error("forward on empty symbol list");
		else{
			std::vector<double> fwd = init_forward();
			for(std::size_t t = 0; t < std::min(symbols.size(), t_max); ++t) {
				fwd = iter_forward(fwd, t);
			}
			return fwd;
		}
	}

	template<typename SymbolContainer>
	std::vector<double> backward(const SymbolContainer& symbols, std::size_t t_min = 0) {
		if(t_min == 0) t_min = 1;
		auto init_backward = [this]() -> std::vector<double> {
			std::vector<double> init_bwd(_A.size());
			if(_is_finite){
				for(std::size_t i = 0; i < _A.size(); ++i){
					init_bwd[i] = _A[i][0];
				}
			}
			else{
				for(std::size_t i = 0; i < _A.size(); ++i){
					init_bwd[i] = 0.0;
				}
			}
			return init_bwd;
		};
		auto iter_backward = [&symbols, this](const std::vector<double>& next_bwd, std::size_t t) -> std::vector<double> {
			std::vector<double> current_bwd(_A.size());
			/* Normale states first. */
			for(std::size_t j = 0; j < _silent_states_index; ++j){
				double prob_sum = utils::kNegInf;
				for(std::size_t i = 0; i < _A.size(); ++i){
					prob_sum = utils::sum_log_prob(prob_sum, _A[j][i] + (*_B[i])[symbols[t + 1]] + next_bwd[i]);	
				}
				current_bwd[j] = prob_sum;
			}
			/* Do first iteration over silent states j with i == normal state. */
			for(std::size_t j = _silent_states_index; j < _A.size(); ++j){
				double prob_sum = utils::kNegInf;
				for(std::size_t i = 0; i < _silent_states_index; ++i){
					prob_sum = utils::sum_log_prob(prob_sum, current_bwd[i] + _A[i][j]);
				}
				current_bwd[j] = prob_sum;
			}
			/* Do second iteration over silent states j with i == silent state < j. Reverse topological order. */
			for(std::size_t j = _A.size() - 1; j >= _silent_states_index; --j){
				double prob_sum = current_bwd[j];
				for(std::size_t i = _A.size() - 1; i > j; --i){
					prob_sum = utils::sum_log_prob(prob_sum, current_bwd[i] + _A[j][i]);
				}
				current_bwd[j] = prob_sum;
			}
			return current_bwd;
		};
		if(symbols.size() == 0) throw std::runtime_error("backward on empty symbol list");
		else{
			std::vector<double> bwd = init_backward();
			for(std::size_t t = symbols.size() - 2; t >= t_min && t < symbols.size(); --t){
				bwd = iter_backward(bwd, t);
			}
			return bwd;
		}
	}

	template<typename Symbol>
	double log_likelihood(const std::vector<Symbol>& symbols, bool do_fwd = true){
		if(do_fwd){
			std::vector<double> fwd = forward(symbols);
			if(_is_finite){
				double prob_sum = utils::kNegInf;
				/* First column of each row has the end state probability. */
				for(std::size_t i = 0; i < fwd.size(); ++i){
					prob_sum = utils::sum_log_prob(prob_sum, fwd[i] + _A[i][0]);
				}
				return prob_sum;
			}
			else{
				double prob_sum = utils::kNegInf;
				for(std::size_t i = 0; i < fwd.size(); ++i){
					prob_sum = utils::sum_log_prob(prob_sum, fwd[i]);
				}
				return prob_sum;
			}
		}
		else{
			std::vector<double> bwd = backward(symbols);
			double prob_sum = utils::kNegInf;
			double bwd_mul;
			for(std::size_t i = 0; i < bwd.size(); ++i){
				bwd_mul = (_B[i] != nullptr) ? _pi_begin[i] + (*_B[i])[symbols[0]] + bwd[i] : _pi_begin[i] + bwd[i];
				prob_sum = utils::sum_log_prob(prob_sum, bwd_mul);	
			}
			return prob_sum;
		}
	}

	template<typename Symbol>
	double likelihood(const std::vector<Symbol>& symbols, bool do_fwd = true){
		return exp(log_likelihood(symbols, do_fwd));
	}

	void sample() {

	}

	struct Traceback {
		struct Node; // forward declaration.
		typedef std::shared_ptr<Node> NodePtr;
		struct Node{
			NodePtr previous;
			std::size_t value;
			Node(std::size_t v) : previous(), value(v) {}
			Node(std::size_t v, NodePtr p) : previous(p), value(v) {}
		};
		std::size_t nodes;
		std::vector<NodePtr> previous_nodes;
		std::vector<NodePtr> current_nodes;
		Traceback(std::size_t num_nodes) : 
			nodes(num_nodes), previous_nodes(nodes), current_nodes(nodes) {
				for(std::size_t i = 0; i < num_nodes; ++i){
					previous_nodes[i] = NodePtr(new Node(i));
				}
			}

		void add_link(std::size_t previous, std::size_t current) {
			current_nodes[current] = NodePtr(new Node(current, previous_nodes[previous]));
		}

		void next_column() {
			previous_nodes = current_nodes;
		}

		std::vector<std::size_t> trace_back(std::size_t previous, std::size_t max_k){
			std::size_t k = max_k;
			std::vector<std::size_t> tb(k);
			NodePtr node_ptr = previous_nodes[previous];
			while(k > 0){
				tb[k - 1] = node_ptr->value;
				if(!node_ptr->previous) break;
				node_ptr = node_ptr->previous; 
				--k;
			}
			if(k > 0) throw std::logic_error("Could not trace back to " + std::to_string(max_k) + ". Stopped at " + std::to_string(k));
			if(node_ptr->previous) throw std::logic_error("Traceback not completed. Previous value: " + std::to_string(node_ptr->previous->value));
			return tb;
		}

	};

	template<typename Symbol>
	std::pair<std::vector<std::string>, double> viterbi(const std::vector<Symbol>& symbols) {
		auto init_viterbi = [&symbols, this]() -> std::pair<std::vector<double>, Traceback>{
			std::vector<double> init_delta(_pi_begin.size());
			for(std::size_t i = 0; i < _pi_begin.size(); ++i){
				init_delta[i] = _pi_begin[i] + (*_B[i])[symbols[0]];
			}
			Traceback init_psi(symbols.size());
			return std::make_pair(init_delta, init_psi);
		};
		auto iter_viterbi = [&symbols, this](const std::vector<double>& previous_delta, Traceback& psi, std::size_t t) -> std::vector<double> {
			std::vector<double> current_delta(_A.size());
			for(std::size_t j = 0; j < _A.size(); ++j){
				double max_delta = utils::kNegInf;
				double delta_i;
				std::size_t max_i;
				for(std::size_t i = 0; i < _A.size(); ++i){
					delta_i = previous_delta[i] + _A[i][j];
					if(delta_i > max_delta){
						max_delta = delta_i;
						max_i = i;
					}
				}
				current_delta[j] = max_delta + (*_B[j])[symbols[t]];
				psi.add_link(max_i, j);
			}
			psi.next_column();
			return current_delta;
		};

		auto terminate_viterbi = [&symbols, this](const std::vector<double>& delta, Traceback& psi) -> std::pair<std::vector<std::string>, double> {
			std::size_t max_delta = (std::size_t) (std::max_element(delta.begin(), delta.end()) - delta.begin());
			std::vector<std::size_t> path_indices = psi.trace_back(max_delta, symbols.size());
			std::vector<std::string> path(path_indices.size());
			for(std::size_t i = 0; i < path_indices.size(); ++i) {
				path[i] = _states_names[path_indices[i]];
			}
			return std::make_pair(path, delta[max_delta]);
		};
		std::pair<std::vector<double>, Traceback> init_viter = init_viterbi();
		std::vector<double> delta = init_viter.first;
		Traceback psi = init_viter.second;
		for(std::size_t t = 0; t < symbols.size(); ++t){
			delta = iter_viterbi(delta, psi, t);
		}
		return terminate_viterbi(delta, psi);
	}

	template<typename Symbol>
	std::pair<std::vector<std::string>, double> decode(std::vector<Symbol>& symbols) {
		return viterbi(symbols);
	}

	void train() {

	}

	void save(){

	}

	void load(){

	}

	virtual ~HiddenMarkovModel(){
		_clear_raw_data();
	}
};


#endif